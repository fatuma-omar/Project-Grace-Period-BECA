<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Effect of grace period on false alarm rates of smartwatch-based OHCA detection systems: a pilot study</title>

  <!-- Highlight.js with Atom One Light theme -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/r.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
  <script>hljs.highlightAll();</script>

  <!-- MathJax for LaTeX rendering -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body {
      background: #ffffff;
      color: #333333;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      padding: 2rem;
    }
    a {
      color: #007acc;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .content {
      max-width: 800px;
      margin: auto;
    }
    pre {
      background: #f6f8fa;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.95rem;
    }
    h1, h2 {
      color: #1e1e2f;
    }
    code {
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    }
  </style>
</head>
<body>
  <div class="content">
    <a href="https://fatuma-omar.github.io/">&larr; Back to projects</a>
<h3>Shared frailty model with loglogistic baseline hazard model</h3>
<p>
We apply a shared frailty model with a log-logistic baseline hazard function. We use the proportional hazards (PH) model, where the effect of covariates is modeled as a multiplicative shift on the hazard function.
Let \( T_{ij} \) denote the response time for participant \( i \) on occasion \( j \), for \( i = 1, \dots, N \) and \( j = 1, \dots, J_i \), with \( T_{ij} > 0 \). The log-logistic baseline hazard is given by:

\[
h_0(t) = \frac{k \lambda^k t^{k-1}}{1 + (\lambda t)^k}
\]

where \( \lambda > 0 \) is the scale parameter and \( k > 0 \) is the shape parameter. For the PH specification, we assume that the hazard function for individual \( i \) at time \( t \) is:

\[
h_{ij}(t \mid x_{ij}, u_i) = h_0(t) \cdot \exp(x_{ij}^\top \beta) \cdot u_i
\]

where:
<ol>
  <li>\( x_{ij} \in \mathbb{R}^K \) is a vector of covariates for the \( j \)-th response of participant \( i \),</li>
  <li>\( \beta \in \mathbb{R}^K \) are the corresponding regression coefficients,</li>
  <li>\( u_i \sim \text{Gamma}(\alpha, \alpha) \) is a shared frailty term specific to participant \( i \).</li>
</ol>

The corresponding cumulative hazard is:

\[
H_{ij}(t \mid x_{ij}, u_i) = u_i \cdot \exp(x_{ij}^\top \beta) \cdot \log \left[ 1 + (\lambda t)^k \right]
\]

The conditional likelihood (given frailty) contribution for each observed response time \( T_{ij} \) with event indicator \( \delta_{ij} \in \{0, 1\} \) is:

\[
L_{ij} = \left[ h_{ij}(T_{ij}) \right]^{\delta_{ij}} \cdot \exp\left( -H_{ij}(T_{ij}) \right)
\]

We place weakly informative priors on all parameters. The frailty terms \( u_i \) are integrated over using their gamma distribution, yielding a marginal likelihood for Bayesian inference. Estimation is performed via Hamiltonian Monte Carlo using Stan.

</p>

<h3>Stan code</h3>

<pre><code class="language-cpp">functions{
  real loglogistic_hazard(real t, real linear_predictor, real log_lambda, real log_k){
    real lambda = exp(log_lambda);
    real k = exp(log_k);
    return exp(linear_predictor)*k*lambda*pow(lambda*t, k - 1)/(1 + pow(lambda*t, k));
  }

  real loglogistic_cumulative_hazard(real t, real linear_predictor, real log_lambda, real log_k){
    real lambda = exp(log_lambda);
    real k = exp(log_k);
    return exp(linear_predictor)*log1p(pow(lambda*t, k));
  }
}

data{
  int&lt;lower = 1&gt; N;
  int&lt;lower = 1&gt; N_subjects;
  int&lt;lower = 1&gt; subject[N];
  int&lt;lower = 0, upper = 1&gt; event[N];
  vector[N] y;
  int&lt;lower = 1&gt; K;
  matrix[N, K] X;
  int&lt;lower = 1&gt; N_times;
  vector[N_times] times;
  int&lt;lower = 0, upper = 1&gt; status_brier[N, N_times];
}

parameters{
  vector[K] beta;
  real log_lambda;
  real log_k;
  real log_alpha;
  vector&lt;lower = 0&gt;[N_subjects] Z;
}

model{
  beta ~ normal(0, 1);
  log_lambda ~ normal(0, 1);
  log_k ~ normal(0, 1);
  log_alpha ~ normal(0, 1);
  Z ~ gamma(exp(log_alpha), exp(log_alpha));

  for(n in 1:N){
    real linear_predictor = dot_product(X[n], beta);
    real hazard = loglogistic_hazard(y[n], linear_predictor, log_lambda, log_k)*Z[subject[n]];
    real cumulative_hazard = loglogistic_cumulative_hazard(y[n], linear_predictor, log_lambda, log_k)*Z[subject[n]];
    target += event[n]*log(hazard) - cumulative_hazard;
  }
}

generated quantities{
  vector[N] log_lik;

  matrix[N, N_times] survival;
  vector[N_times] Brier_Score;
  vector[N_times] mean_survival;

  vector[N_times] Brier_alarm_B;
  vector[N_times] mean_survival_alarm_B;

  vector[N_times] Brier_alarm_not_B;
  vector[N_times] mean_survival_alarm_not_B;

  real variance_Z = 1/exp(log_alpha);
  real kendalls_tau_Z = exp(log_alpha)/(2 + exp(log_alpha));

  for(n in 1:N){
    real linear_predictor = dot_product(X[n], beta);
    real hazard = loglogistic_hazard(y[n], linear_predictor, log_lambda, log_k)*Z[subject[n]];
    real cumulative_hazard = loglogistic_cumulative_hazard(y[n], linear_predictor, log_lambda, log_k)*Z[subject[n]];
    log_lik[n] = event[n]*log(hazard) - cumulative_hazard;
  }

  for(t in 1:N_times){
    real total_survival = 0;
    real total_squared_error = 0;

    real total_survival_B = 0;
    real total_squared_error_B = 0;
    int count_B = 0;

    real total_survival_not_B = 0;
    real total_squared_error_not_B = 0;
    int count_not_B = 0;

    for(n in 1:N){
      real linear_predictor = dot_product(X[n], beta);
      real cumulative_hazard = loglogistic_cumulative_hazard(times[t], linear_predictor, log_lambda, log_k)*Z[subject[n]];
      real survival_probability = exp(-cumulative_hazard);
      real squared_error = square((1 - status_brier[n, t]) - survival_probability);

      survival[n, t] = survival_probability;

      total_survival += survival_probability;
      total_squared_error += squared_error;

      if(X[n,1] == 1){
        total_survival_B += survival_probability;
        total_squared_error_B += squared_error;
        count_B += 1;
      }
      if(X[n,1] == 0){
        total_survival_not_B += survival_probability;
        total_squared_error_not_B += squared_error;
        count_not_B += 1;
      }
    }

    mean_survival[t] = total_survival/N;
    Brier_Score[t] = total_squared_error/N;

    mean_survival_alarm_B[t] = count_B &gt; 0 ? total_survival_B/count_B : 0;
    Brier_alarm_B[t] = count_B &gt; 0 ? total_squared_error_B/count_B : 0;

    mean_survival_alarm_not_B[t] = count_not_B &gt; 0 ? total_survival_not_B/count_not_B : 0;
    Brier_alarm_not_B[t] = count_not_B &gt; 0 ? total_squared_error_not_B/count_not_B : 0;
  }
}
</code></pre>

<h3>R code</h3>


    <p>View the full code on <a href="https://github.com/fatuma-omar/Project-Grace-Period-BECA/" target="_blank">GitHub</a>.</p>
  </div>
</body>
</html>
